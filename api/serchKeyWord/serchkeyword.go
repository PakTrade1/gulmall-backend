package serchkeyword

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	docking "pak-trade-go/Docking"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type serchkey struct {
	User_public_id int    `json:"userId"`
	Keyword        string `json:"keyword"`
}
type resp_insert struct {
	Status  int         `json:"status"`
	Message string      `json:"message"`
	Id      interface{} `json:"id"`
}

// func Serchkeywordinsert(w http.ResponseWriter, req *http.Request) {

// 	w.Header().Set("Content-Type", "application/json")
// 	w.Header().Set("Access-Control-Allow-Origin", "*")

// 	var keyserch serchkey
// 	err := json.NewDecoder(req.Body).Decode(&keyserch)
// 	if err != nil {
// 		panic(err)
// 	}

// 	// mongo

// 	// Convert string to ObjectID
// 	inputString := keyserch.User_public_id

// 	// Convert string to ObjectID
// 	objectID, err := primitive.ObjectIDFromHex(inputString)
// 	if err != nil {
// 		fmt.Println("Error:", err)
// 		return
// 	}

// 	coll := docking.PakTradeDb.Collection("searched_keyword")

// 	mongo_query := bson.M{
// 		"keyword": keyserch.Keyword,
// 		"userId":  objectID,
// 		"time":    time.Now(),
// 	}

// 	// // // insert a user

// 	inset, err3 := coll.InsertOne(context.TODO(), mongo_query)
// 	if err3 != nil {
// 		fmt.Fprintf(w, "%s\n", err3)
// 	}
// 	var results resp_insert
// 	if inset != nil {
// 		results.Status = http.StatusOK
// 		results.Message = "success"

// 	} else {
// 		results.Message = "decline"

// 	}

// 	results.Id = inset.InsertedID
// 	output, err := json.MarshalIndent(results, "", "    ")
// 	if err != nil {
// 		panic(err)

// 	}

// 	fmt.Fprintf(w, "%s\n", output)

// }

type respone_struct1 struct {
	Status      int             `json:"status"`
	Message     string          `json:"message"`
	TotalRecord int             `json:"totalRecord"`
	Data        []AutoGenerated `json:"data"`
}
type respone_one_item struct {
	Status  int             `json:"status"`
	Message string          `json:"message"`
	Data    []AutoGenerated `json:"data"`
}
type AutoGenerated struct {
	ID           primitive.ObjectID `bson:"_id,omitempty"`
	ParentId     primitive.ObjectID `json:"parentId"`
	HasDimension bool               `json:"hasDimension"`
	PublicID     int                `json:"publicId"`
	Name         string             `json:"name"`
	Feature      []struct {
		Name string `json:"name"`
	} `json:"feature"`
	Images []struct {
		Image string `json:"image"`
		Color string `json:"color"`
	} `json:"images"`
	Category struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name        string `json:"name"`
		Gender_flag bool   `json:"gender_flag"`
		Icon        string `json:"icon"`
	} `json:"category"`
	Sub_category struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name string `json:"name"`

		Icon string `json:"icon"`
	} `json:"sub_category"`
	Gender        string `json:"gender"`
	Price         int    `json:"price"`
	Qty           int    `json:"qty"`
	Remaining_qty int    `json:"remaining_qty"`
	Status        string `json:"status"`
	Color         []struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		CSSHex string `json:"cssHex"`
		Name   string `json:"name"`
	} `json:"color"`
	Size []struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name string `json:"name"`
	} `json:"size"`
	OwnerName string `json:"ownerName"`
	Title     string `json:"title"`
	Country   string `json:"country"`
	Currency  string `json:"currency"`
	Plan      struct {
		// Price      int    `json:"price"`
		Name  string `json:"name"`
		Order int    `json:"order"`
		// AdDuration int    `json:"adDuration"`
	}
	TotalRecord int       `json:"totalRecord"`
	Dimension   Dimension `json:"dimension"`
}
type Dimension struct {
	Length *struct {
		Unit  string  `json:"unit"`
		Value float64 `json:"value"`
	} `json:"length"`
	Width *struct {
		Unit  string `json:"unit"`
		Value int    `json:"value"`
	} `json:"width"`
}
type recordCount struct {
	RecodTotal int `bson:"totalRecord"`
}

func Get_all_items_serchkey(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	var keyserch serchkey
	err := json.NewDecoder(req.Body).Decode(&keyserch)
	if err != nil {
		panic(err)
	}

	coll := docking.PakTradeDb.Collection("items-parent")
	coll1 := docking.PakTradeDb.Collection("searched_keyword")

	mongo_query := bson.M{
		"keyword": keyserch.Keyword,
		"userId":  keyserch.User_public_id,
		"time":    time.Now(),
	}

	// // // insert a user

	_, err3 := coll1.InsertOne(context.TODO(), mongo_query)
	if err3 != nil {
		fmt.Fprintf(w, "%s\n", err3)
	}

	pageN := req.URL.Query().Get("pageNumber")
	pageNu, err := strconv.Atoi(pageN)
	if err != nil || pageNu <= 0 {
		pageNu = 1
	}

	ctx := context.TODO()
	pageNumber := pageNu
	pageSize := 10
	mongoquery := bson.A{bson.D{
		{"$lookup",
			bson.D{
				{"from", "cloths"},
				{"localField", "_id"},
				{"foreignField", "parentId"},
				{"as", "cloths"},
			},
		},
	},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "Mammalas_login"},
					{"localField", "ownerId"},
					{"foreignField", "_id"},
					{"as", "name"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "categories"},
					{"localField", "category"},
					{"foreignField", "_id"},
					{"as", "category"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category"},
					{"localField", "category._id"},
					{"foreignField", "cat_id"},
					{"as", "subcat"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category_child"},
					{"localField", "subcat._id"},
					{"foreignField", "sub_category_id"},
					{"as", "child"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "color"},
					{"localField", "cloths.availableColor"},
					{"foreignField", "_id"},
					{"as", "color"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "size"},
					{"localField", "cloths.size.availableSize"},
					{"foreignField", "_id"},
					{"as", "size"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "plans"},
					{"localField", "planId"},
					{"foreignField", "_id"},
					{"as", "plan"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "tier"},
					{"localField", "plan.tierId"},
					{"foreignField", "_id"},
					{"as", "tier"},
				},
			},
		},
		bson.D{
			{"$set",
				bson.D{
					{"name", bson.D{{"$first", "$name.displayName"}}},
					{"child", bson.D{{"$first", "$child.name"}}},
					{"categoryName", bson.D{{"$first", "$category.name"}}},
					{"category", bson.D{{"$first", "$category"}}},
					{"subcat", bson.D{{"$first", "$subcat"}}},
					{"subcatName", bson.D{{"$first", "$subcat.name"}}},
					{"clothName", bson.D{{"$first", "$cloths.name"}}},
					{"tier", bson.D{{"$first", "$tier"}}},
					{"tierName", bson.D{{"$first", "$tier.name"}}},
					{"item", bson.D{{"$first", "$cloths"}}},
					{"plan", bson.D{{"$first", "$plan"}}},
				},
			},
		},
		bson.D{
			{"$match",
				bson.D{
					{"$or",
						bson.A{
							bson.D{{"title", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"country", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"image", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"categoryName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"subcatName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"child", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"clothName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"tier.name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"color.name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"item.feature.name", bson.D{{"$regex", keyserch.Keyword}}}},
						},
					},
				},
			},
		},
		bson.D{
			{"$project",
				bson.D{
					{"name", "$item.name"},
					{"feature", "$item.feature"},
					{"images", "$images"},
					{"_id", "$item._id"},
					{"parentId", "$item.parentId"},
					{"category", "$category"},
					{"sub_category", "$subcat"},
					{"gender", "$item.gender"},
					{"price", "$price"},
					{"qty", "$qty"},
					{"remaining_qty", "$remainingQty"},
					{"status", "$status"},
					{"country", "$country"},
					{"color", "$color"},
					{"size", "$size"},
					{"title", "$title"},
					{"ownerName", "$name"},
					{"plan",
						bson.D{
							{"price", "$plan.price"},
							{"name", "$tier.name"},
							{"order", "$tier.order"},
							{"adDuration", "$plan.ad_duration"},
						},
					},
				},
			},
		},
		// bson.D{
		// 	{"$skip", (pageNumber - 1) * pageSize},
		// },
		// bson.D{
		// 	{"$limit", pageSize},
		// },
		bson.D{{"$count", "totalRecord"}},
	}
	mongoquery1 := bson.A{
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "cloths"},
					{"localField", "_id"},
					{"foreignField", "parentId"},
					{"as", "cloths"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "Mammalas_login"},
					{"localField", "ownerId"},
					{"foreignField", "_id"},
					{"as", "name"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "categories"},
					{"localField", "category"},
					{"foreignField", "_id"},
					{"as", "category"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category"},
					{"localField", "category._id"},
					{"foreignField", "cat_id"},
					{"as", "subcat"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category_child"},
					{"localField", "subcat._id"},
					{"foreignField", "sub_category_id"},
					{"as", "child"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "color"},
					{"localField", "cloths.availableColor"},
					{"foreignField", "_id"},
					{"as", "color"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "size"},
					{"localField", "cloths.size.availableSize"},
					{"foreignField", "_id"},
					{"as", "size"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "plans"},
					{"localField", "planId"},
					{"foreignField", "_id"},
					{"as", "plan"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "tier"},
					{"localField", "plan.tierId"},
					{"foreignField", "_id"},
					{"as", "tier"},
				},
			},
		},
		bson.D{
			{"$set",
				bson.D{
					{"name", bson.D{{"$first", "$name.displayName"}}},
					{"child", bson.D{{"$first", "$child.name"}}},
					{"categoryName", bson.D{{"$first", "$category.name"}}},
					{"category", bson.D{{"$first", "$category"}}},
					{"subcat", bson.D{{"$first", "$subcat"}}},
					{"subcatName", bson.D{{"$first", "$subcat.name"}}},
					{"clothName", bson.D{{"$first", "$cloths.name"}}},
					{"tier", bson.D{{"$first", "$tier"}}},
					{"tierName", bson.D{{"$first", "$tier.name"}}},
					{"item", bson.D{{"$first", "$cloths"}}},
					{"plan", bson.D{{"$first", "$plan"}}},
					{"colorName", bson.D{{"$first", "$color.Name"}}},
				},
			},
		},
		bson.D{
			{"$match",
				bson.D{
					{"$or",
						bson.A{
							bson.D{{"title", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"country", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"image", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"categoryName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"subcatName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"child", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"clothName", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"tier.name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"color.name", bson.D{{"$regex", keyserch.Keyword}}}},
							bson.D{{"item.feature.name", bson.D{{"$regex", keyserch.Keyword}}}},
						},
					},
				},
			},
		},
		bson.D{
			{"$project",
				bson.D{
					{"name", "$item.name"},
					{"feature", "$item.feature"},
					{"images", "$images"},
					{"_id", "$item._id"},
					{"parentId", "$item.parentId"},
					{"category", "$category"},
					{"sub_category", "$subcat"},
					{"gender", "$item.gender"},
					{"price", "$price"},
					{"qty", "$qty"},
					{"remaining_qty", "$remainingQty"},
					{"status", "$status"},
					{"country", "$country"},
					{"color", "$color"},
					{"size", "$size"},
					{"title", "$title"},
					{"ownerName", "$name"},
					{"plan",
						bson.D{
							{"price", "$plan.price"},
							{"name", "$tier.name"},
							{"order", "$tier.order"},
							{"adDuration", "$plan.ad_duration"},
						},
					},
				},
			},
		},
		bson.D{
			{"$skip", (pageNumber - 1) * pageSize},
		},
		bson.D{
			{"$limit", pageSize},
		},
	}

	aggOptions := options.Aggregate()
	aggOptions.SetAllowDiskUse(true)

	cursor, err := coll.Aggregate(ctx, mongoquery1, aggOptions)
	if err != nil {
		log.Fatal(err)
	}
	defer cursor.Close(context.TODO())
	cursorCount, err := coll.Aggregate(ctx, mongoquery, aggOptions)
	if err != nil {
		log.Fatal(err)
	}
	defer cursorCount.Close(context.TODO())

	///////////////////// Totla Recrod

	///////////////// End total record

	var results respone_struct1
	var resp1 []AutoGenerated

	for cursor.Next(context.TODO()) {
		var xy AutoGenerated
		cursor.Decode(&xy)
		resp1 = append(resp1, xy)

	}

	var totalRecord recordCount
	if cursorCount.Next(context.TODO()) {
		if err := cursorCount.Decode(&totalRecord); err != nil {
			fmt.Println("Error decoding cursor:", err)
		}
	}

	// ///////////
	// Populate resp1 and resp2 with data

	//////////////

	if resp1 != nil {
		results.Status = http.StatusOK
		results.Message = "success"
		results.TotalRecord = totalRecord.RecodTotal
		results.Data = resp1

	} else {
		results.Message = "decline"

	}

	// results.Data =
	output, err := json.MarshalIndent(results, "", "    ")
	if err != nil {
		panic(err)

	}

	fmt.Fprintf(w, "%s\n", output)

}
