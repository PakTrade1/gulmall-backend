package serchkeyword

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	docking "pak-trade-go/Docking"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type serchkey struct {
	User_public_id string `json:"user_id"`
	Keyword        string `json:"keyword"`
}
type resp_insert struct {
	Status  int         `json:"status"`
	Message string      `json:"message"`
	Id      interface{} `json:"id"`
}

func Serchkeywordinsert(w http.ResponseWriter, req *http.Request) {

	w.Header().Set("Content-Type", "application/json")
	// w.Header().Set("Access-Control-Allow-Origin", "*")

	var keyserch serchkey
	err := json.NewDecoder(req.Body).Decode(&keyserch)
	if err != nil {
		panic(err)
	}

	// mongo

	// Convert string to ObjectID
	inputString := keyserch.User_public_id

	// Convert string to ObjectID
	objectID, err := primitive.ObjectIDFromHex(inputString)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	mongo_query := bson.M{
		"keyword": keyserch.Keyword,
		"userId":  objectID,
		"time":    time.Now(),
	}

	coll := docking.PakTradeDb.Collection("searched_keyword")

	// // // insert a user

	inset, err3 := coll.InsertOne(context.TODO(), mongo_query)
	if err3 != nil {
		fmt.Fprintf(w, "%s\n", err3)
	}
	var results resp_insert
	if inset != nil {
		results.Status = http.StatusOK
		results.Message = "success"

	} else {
		results.Message = "decline"

	}

	results.Id = inset.InsertedID
	output, err := json.MarshalIndent(results, "", "    ")
	if err != nil {
		panic(err)

	}

	fmt.Fprintf(w, "%s\n", output)

}

type respone_struct1 struct {
	Status      int             `json:"status"`
	Message     string          `json:"message"`
	TotalRecord int             `json:"totalRecord"`
	Data        []AutoGenerated `json:"data"`
}
type respone_one_item struct {
	Status  int             `json:"status"`
	Message string          `json:"message"`
	Data    []AutoGenerated `json:"data"`
}
type AutoGenerated struct {
	ID           primitive.ObjectID `bson:"_id,omitempty"`
	ParentId     primitive.ObjectID `json:"parentId"`
	HasDimension bool               `json:"hasDimension"`
	PublicID     int                `json:"publicId"`
	Name         string             `json:"name"`
	Feature      []struct {
		Name string `json:"name"`
	} `json:"feature"`
	Images []struct {
		Image string `json:"image"`
		Color string `json:"color"`
	} `json:"images"`
	Category struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name        string `json:"name"`
		Gender_flag bool   `json:"gender_flag"`
		Icon        string `json:"icon"`
	} `json:"category"`
	Sub_category struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name string `json:"name"`

		Icon string `json:"icon"`
	} `json:"sub_category"`
	Gender        string `json:"gender"`
	Price         int    `json:"price"`
	Qty           int    `json:"qty"`
	Remaining_qty int    `json:"remaining_qty"`
	Status        string `json:"status"`
	Color         []struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		CSSHex string `json:"cssHex"`
		Name   string `json:"name"`
	} `json:"color"`
	Size []struct {
		ID primitive.ObjectID `bson:"_id,omitempty"`

		Name string `json:"name"`
	} `json:"size"`
	OwnerName string `json:"ownerName"`
	Title     string `json:"title"`
	Country   string `json:"country"`
	Currency  string `json:"currency"`
	Plan      struct {
		// Price      int    `json:"price"`
		Name  string `json:"name"`
		Order int    `json:"order"`
		// AdDuration int    `json:"adDuration"`
	}
	TotalRecord int       `json:"totalRecord"`
	Dimension   Dimension `json:"dimension"`
}
type Dimension struct {
	Length *struct {
		Unit  string  `json:"unit"`
		Value float64 `json:"value"`
	} `json:"length"`
	Width *struct {
		Unit  string `json:"unit"`
		Value int    `json:"value"`
	} `json:"width"`
}

func Get_all_items_serchkey(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	coll := docking.PakTradeDb.Collection("cloths")
	coll1 := docking.PakTradeDb.Collection("items-parent")

	pageN := req.URL.Query().Get("pageNumber")
	pageNu, err := strconv.Atoi(pageN)
	if err != nil || pageNu <= 0 {
		pageNu = 1
	}

	ctx := context.TODO()
	pageNumber := pageNu
	pageSize := 10
	mongoquery := bson.A{
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "items-parent"},
					{"localField", "parentId"},
					{"foreignField", "_id"},
					{"as", "parent"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "color"},
					{"localField", "availableColor"},
					{"foreignField", "_id"},
					{"as", "color"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "size"},
					{"localField", "size.availableSize"},
					{"foreignField", "_id"},
					{"as", "size"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "size_chart"},
					{"localField", "size.sizeChart"},
					{"foreignField", "_id"},
					{"as", "sizeChart"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category"},
					{"localField", "parent.subCategory"},
					{"foreignField", "_id"},
					{"as", "sub_cat"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "categories"},
					{"localField", "parent.category"},
					{"foreignField", "_id"},
					{"as", "cat"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "plans"},
					{"localField", "parent.planId"},
					{"foreignField", "_id"},
					{"as", "plans"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "Mammalas_login"},
					{"localField", "parent.ownerId"},
					{"foreignField", "_id"},
					{"as", "owner"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "tier"},
					{"localField", "plans.tierId"},
					{"foreignField", "_id"},
					{"as", "tier"},
				},
			},
		},
		bson.D{
			{"$lookup",
				bson.D{
					{"from", "sub_category_child"},
					{"localField", "sub_cat._id"},
					{"foreignField", "sub_category_id"},
					{"as", "child"},
				},
			},
		},
		bson.D{
			{"$set",
				bson.D{
					{"parent", bson.D{{"$first", "$parent"}}},
					{"category", bson.D{{"$first", "$cat"}}},
					{"subCategory", bson.D{{"$first", "$sub_cat"}}},
					{"plans", bson.D{{"$first", "$plans"}}},
					{"tier", bson.D{{"$first", "$tier"}}},
					{"owner", bson.D{{"$first", "$owner"}}},
					{"title", bson.D{{"$first", "$parent.title"}}},
					{"country", bson.D{{"$first", "$parent.country"}}},
					{"image", bson.D{{"$first", "$parent.image"}}},
					{"category1", bson.D{{"$first", "$cat.name"}}},
					{"subcat", bson.D{{"$first", "$sub_cat.name"}}},
					{"child", bson.D{{"$first", "$child.name"}}},
					{"name", bson.D{{"$first", "$owner.displayName"}}},
				},
			},
		},
		bson.D{
			{"$match",
				bson.D{
					{"$or",
						bson.A{
							bson.D{{"title", bson.D{{"$regex", "oman"}}}},
							bson.D{{"country", bson.D{{"$regex", "pak"}}}},
							bson.D{{"image", bson.D{{"$regex", "oman"}}}},
							bson.D{{"category", bson.D{{"$regex", "oman"}}}},
							bson.D{{"subcat", bson.D{{"$regex", "oman"}}}},
							bson.D{{"child", bson.D{{"$regex", "oman"}}}},
							bson.D{{"name", bson.D{{"$regex", "oman"}}}},
						},
					},
				},
			},
		},
		bson.D{
			{"$project",
				bson.D{
					{"name", "$name"},
					{"feature", "$feature"},
					{"images", "$parent.images"},
					{"_id", "$_id"},
					{"parentId", "$parent._id"},
					{"category", "$category"},
					{"sub_category", "$subCategory"},
					{"gender", "$gender"},
					{"price", "$parent.price"},
					{"qty", "$parent.qty"},
					{"remaining_qty", "$parent.remainingQty"},
					{"status", "$parent.status"},
					{"country", "$_id.country"},
					{"color", "$color"},
					{"size", "$size"},
					{"title", "$parent.title"},
					{"ownerName", "$owner.displayName"},
					{"plan",
						bson.D{
							{"price", "$plans.price"},
							{"name", "$tier.name"},
							{"order", "$tier.order"},
							{"adDuration", "$plans.ad_duration"},
						},
					},
				},
			},
		},
		bson.D{
			{"$skip", (pageNumber - 1) * pageSize},
		},
		bson.D{
			{"$limit", pageSize},
		},
	}
	// []bson.D{

	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "items-parent"},
	// 				{"localField", "parentId"},
	// 				{"foreignField", "_id"},
	// 				{"as", "parent"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "color"},
	// 				{"localField", "availableColor"},
	// 				{"foreignField", "_id"},
	// 				{"as", "color"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "size"},
	// 				{"localField", "size.availableSize"},
	// 				{"foreignField", "_id"},
	// 				{"as", "size"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "size_chart"},
	// 				{"localField", "size.sizeChart"},
	// 				{"foreignField", "_id"},
	// 				{"as", "sizeChart"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "sub_category"},
	// 				{"localField", "parent.subCategory"},
	// 				{"foreignField", "_id"},
	// 				{"as", "sub_cat"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "categories"},
	// 				{"localField", "parent.category"},
	// 				{"foreignField", "_id"},
	// 				{"as", "cat"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "plans"},
	// 				{"localField", "parent.planId"},
	// 				{"foreignField", "_id"},
	// 				{"as", "plans"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "Mammalas_login"},
	// 				{"localField", "parent.ownerId"},
	// 				{"foreignField", "_id"},
	// 				{"as", "owner"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$lookup",
	// 			bson.D{
	// 				{"from", "tier"},
	// 				{"localField", "plans.tierId"},
	// 				{"foreignField", "_id"},
	// 				{"as", "tier"},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$set",
	// 			bson.D{
	// 				{"parent", bson.D{{"$first", "$parent"}}},
	// 				{"category", bson.D{{"$first", "$cat"}}},
	// 				{"subCategory", bson.D{{"$first", "$sub_cat"}}},
	// 				{"plans", bson.D{{"$first", "$plans"}}},
	// 				{"tier", bson.D{{"$first", "$tier"}}},
	// 				{"owner", bson.D{{"$first", "$owner"}}},
	// 			},
	// 		},
	// 	},

	// 	bson.D{
	// 		{"$project",
	// 			bson.D{
	// 				{"name", "$name"},
	// 				{"hasDimension", "$hasDimension"},
	// 				{"feature", "$feature"},
	// 				{"images", "$parent.images"},
	// 				{"_id", "$_id"},
	// 				{"parentId", "$parentId"},
	// 				{"category", "$category"},
	// 				{"sub_category", "$subCategory"},
	// 				{"gender", "$gender"},
	// 				{"price", "$parent.price"},
	// 				{"qty", "$parent.qty"},
	// 				{"remaining_qty", "$parent.remainingQty"},
	// 				{"status", "$parent.status"},
	// 				{"country", "$parent.country"},
	// 				{"currency", "$parent.currency"},
	// 				{"publicId", "$parent.publicId"},

	// 				{"color", "$color"},
	// 				{"size", "$size"},
	// 				{"title", "$parent.title"},
	// 				{"ownerName", "$owner.displayName"},
	// 				{"totalRecord", "$string"},
	// 				{"plan",
	// 					bson.D{
	// 						{"price", "$plans.price"},
	// 						{"name", "$tier.name"},
	// 						{"order", "$tier.order"},
	// 						{"adDuration", "$plans.ad_duration"},
	// 					},
	// 				},
	// 				{"dimension",
	// 					bson.D{
	// 						{"width",
	// 							bson.D{
	// 								{"unit", "$dimension.width.unit"},
	// 								{"value", "$dimension.width.value"},
	// 							},
	// 						},
	// 						{"length",
	// 							bson.D{
	// 								{"unit", "$dimension.length.unit"},
	// 								{"value", "$dimension.length.value"},
	// 							},
	// 						},
	// 					},
	// 				},
	// 			},
	// 		},
	// 	},
	// 	bson.D{
	// 		{"$sort",
	// 			bson.D{
	// 				{"plan.order", 1},
	// 			},
	// 		},
	// 	},

	// bson.D{
	// 	{"$skip", (pageNumber - 1) * pageSize},
	// },
	// bson.D{
	// 	{"$limit", pageSize},
	// },
	// }
	// Open an pagination cursor

	// opts := options.Find().SetSkip(int64((page - 1) * pageSize)).SetLimit(int64(pageSize))
	aggOptions := options.Aggregate()
	aggOptions.SetAllowDiskUse(true)

	cursor, err := coll.Aggregate(ctx, mongoquery, aggOptions)
	if err != nil {
		log.Fatal(err)
	}
	defer cursor.Close(context.TODO())

	///////////////////// Totla Recrod
	pipeline := []bson.D{
		bson.D{
			{"$count", "totalRecords"},
		},
	}

	cursor1, err2 := coll1.Aggregate(ctx, pipeline)
	if err2 != nil {
		log.Fatal(err2)
	}
	defer cursor1.Close(context.TODO())

	var Totalcontrecord struct {
		TotalRecords int `json:"totalRecords"`
	}
	if cursor1.Next(context.TODO()) {
		if err := cursor1.Decode(&Totalcontrecord); err != nil {
			log.Fatal(err)
		}
	}

	///////////////// End total record

	var results respone_struct1
	var resp1 []AutoGenerated

	for cursor.Next(context.TODO()) {
		var xy AutoGenerated
		cursor.Decode(&xy)
		resp1 = append(resp1, xy)

	}

	// ///////////
	// Populate resp1 and resp2 with data

	//////////////

	if resp1 != nil {
		results.Status = http.StatusOK
		results.Message = "success"
		results.TotalRecord = Totalcontrecord.TotalRecords
		results.Data = resp1

	} else {
		results.Message = "decline"

	}

	// results.Data =
	output, err := json.MarshalIndent(results, "", "    ")
	if err != nil {
		panic(err)

	}

	fmt.Fprintf(w, "%s\n", output)

}
